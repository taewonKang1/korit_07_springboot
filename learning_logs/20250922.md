# 입실 체크 해주세요 !! 💌
# korit_07_springboot 폴더 생성
1. learning_logs 폴더 생성 및 20250922.md 파일 생성
2. 현재 korit_07_springboot가 루트 폴더인 상황에서
3. alt + f12 눌러서 터미널 켜고
4. git init
5. git config user.name "여러분깃허브아이디"
6. git config user.email "여러분@깃허브.이메일"
7. chrome -> github 들어가셔서 로그인하겠습니다.
8. repository 생성 후에
9. git add .
10. git commit -m "first commit"
11. git branch -M main
12. git remote add origin "여러분깃허브url"
13. git push -u origin main

# 백엔드 환경 및 툴 설정
1. intellij installation - 이미 완료
2. gradle

## gradle의 이해
- 소프트웨어 개발 프로세0스를 간소화 및 통합하는 빌드 자동화 툴이며, _프로젝트 의존성을 관리하고 빌드 프로세스를 처리_ 한다.
- Springboot와 함께 메이븐(Maven)이라는 다른 프로젝트 관리 도구를 쓸 수도 있지만 가시성이 좋은 gradle을 선택했습니다.
- gradle의 구성은 프로젝트의 build.gradle 파일에서 수행. 이 파일은 프로젝트의 특정 요구 사항에 맞게 사용자가 지정 가능하며 소프트웨어 빌드, 테스트 및 배포와 같은 작업을 자동화하는 데 이용 가능.
- 이상의 파일은 일반적으로 프로젝트 컴파일에 필요한 외부 라이브러리 및 프레임워크 등 프로젝트의 의존성에 대한 정보를 포함(저희가 Java를 할 때는 Lombok 설치가 이루어졌었습니다).
- build.gradle 파일을 작성할 때 Kotlin 또는 Groovy 프로그래밍 언어를 사용할 수 있는데, 저희는 Groovy로 선택했었습니다.

### 일반적인 build.gradle 내부의 항목
1. 플러그인(plugins) : 플러그인 블록은 프로젝트에서 쓰이는 gradle 플러그인을 정의하는 곳이며 저희는 이제 롬복 뿐만 아니라 springboot 버전도 명시할겁니다.

2. 리포지토리(repository) : 의존성을 해결하는 데 쓰이는 의존성 리포지토리를 정의. 여기서는 gradle이 의존성을 가져오기 위해 Maven Central 리포지토리를 사용할 예정입니다.

3. 의존성(dependencies) : 프로젝트에서 이용되는 _의존성_ 지정(의존성 오늘 수업 예정)

4. 태스크(tasks) : 테스트 등의 빌드 프로세스의 일부인 태스크를 정의.

### 스프링 이니셜라이저 활용
https://start.spring.io

1. Spring Web : Web 개발 관련 설정을 default로 가지고 있는 의존성.
2. Spring Boot Dev Tools : 재동 재시작 기능을 제공하는 의존성으로, 변경 내용을 저장할 때마다 애플리케이션이 자동 재시작되므로 덜귀찮습니다.

```java
package com.example.cardatabase;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication {

	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
	}
}
```
이상의 main에서 처음 보는 애너테이션인 `@SpringBootApplication`이 있습니다.
여러 애너테이션의 조합으로 이루어진 것으로 필요한 부분들만 정리하도록 하겠습니다.
1. @EnableAutoConfiguration
    - 스프링부트의 자동 구성을 활성화. 프로젝트가 의존성에 따라 자동으로 구성되는데, 예를 들어 spring-boot-starter-web 의존성이 있는 경우 스프링 부트는 사용자가 웹 애플리케이션을 개발 중이라고 가정하고, 그에 따라 애플리케이션을 알아서 설정해줍니다.
2. @ComponentScan 
    - 스프링 부트 컴포넌트 검색으로 애플리케이션의 모든 컴포넌트를 찾을 수 있도록 함.
3. @Configuration
    - Bean 정의를 제공하는 소스로 쓸 수 있는 클래스를 지정.

### Spring Boot Dev Tools
- 이상의 의존성은 애플리케이션 개발 프로세스를 간략화해주는 의존성으로, 가장 중요한 것 중 하나는 클래스 경로의 파일이 수정될 때마다 스프링 부트 애플리케이션을 자동으로 재시작해준다는 겁니다.

### Logging / Problem-Solution
- 저희가 한국인이라서 콘솔에 딸려있는 영어 보는 걸 끔찍하게 싫어하기는 하는데 로깅은 애플리케이션의 흐름을 모니터링하는 데 이용할 수 있고, 프로그램 코드의 예기치 않은 오류를 포착할 수 있는 좋은 방법입니다. Spring Boot Starter 패키지에는 별도의 구성 없이 로깅에 이용할 수 있는 LogBack이 있습니다.
- 로그백은 SLF4J(Simple Logging Facade For Java)를 기본 인터페이스로 사용합니다.

```java
package com.example.cardatabase;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication {
	private static final Logger logger = LoggerFactory.getLogger(
			CardatabaseApplication.class
	);

	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
		logger.info("Application Started ! / 애플리케이션이 실행되었습니다.");
	}
}
```
이상에서 이제 주의할 점은 아까 전에 보신 것처럼 Logger 하나 import 하려고 할 때도 동일한 이름을 지닌 클래스 / 인터페이스가 많다는 점입니다. 그래서 앞으로 수업을 할 때 웬만하면 import 경로도 같이 알려드리게 될텐데, 혹시나 강사가 실행한 결과값과 다르거나 아니면 아예 빨간 줄 뜨는 경우에는 import 경로도 한 번 확인해주셔야 합니다.

logger.info() 메서드는 로그 메시지를 콘솔에 출력합니다.

그리고 로깅 수준에는 TRACE / DEGUG / INFO / WARN / ERROR / FATAL / OFF 7 가지로 나뉩니다. 이를 application.properties에서 설정할 수 있습니다. 이는 저희가 Java 할 때는 한 번도 본 적 없었던 resources 폴더 내에 있습니다.
`logging.level.root=DEBUG`로 작성한다면, 로그 수준이 DEBUG 및 그 이상(즉, DEBUG / INFO / WARN / ERROR)에 해당하는 로그 메시지를 볼 수 있습니다.

그리고 만약에 다시 재시작하게 된다면 TRACE 관련 메시지는 표시되지 않습니다. 별도로 지정하지 않은 default 로깅 수준은 INFO에 해당합니다.

근데 이거 제가 수업해보니까 죽었다 깨어나도 콘솔을 안보기 때문에 나중에 사용되는지 여부를 물어봤을 때 수강생분들이 잘 안쓰긴 했습니다...

그리고 스프링부트의 기본 port 번호는 8080에 해당합니다.
수강생분들이 너무 너무너무 많이 실수하는 것 중 하나는 코드를 수정했을 때 바로 실행 버튼을 눌러서 port number가 겹쳐서 실행이 안되는 경우입니다. 그래서 제 수업 중에서는 코드 수정 후에 종료를 누르는 것을 일단 통제하도록 하겠습니다.

그럼 저희 현재 port 구성을 확인해보면
Springboot : 8080
MariaDB : 3310
으로 기억해두시면 됩니다.

# 의존성 주입(Dependency Injection)
## 정의
- 다른 객체에 의존하는 객체를 만들 수 있는 소프트웨어 개발 기법.
- 클래스 간의 상호작용을 도우면서 동시에 클래스를 독립적으로 유지
- 의존성 주입의 세 가지 클래스 유형
   1. 서비스(Service) : 클라이언트가 이용할 수 있는 클래스(의존성)
   2. 클라이언트(Client) : 의존성을 이용하는 클래스
   3. 주입기(Injector) : 의존성(서비스)을 의존 클래스(클라이언트)에 전달.

의존성 주입을 통해 클래스를 느슨하게 연결하는 것이 가능합니다. 즉, 클라이언트 의존성의 생성이 클라이언트의 작동과 분리되어 단위 테스트가 더 쉬워집니다.

예를 들어 일반적인 형태의 객체 생성 과정을 보겠습니다.

```java
public class Car {
    // 필드 정의
    private Owner owner;
    // 생성자
    public Car() {
        this.owner = new Owner();
    }
}
```
이상의 코드는 클라이언트 클래스인 Car가 서비스 클래스(Owner)의 객체를 생성하기 때문에 의존성 주입이 없습니다.

그리고 또 이하의 코드를 확인하겠습니다
```java
public class Car {
    private Owner owner;
    public Car(Owner owner) {
        this.owner = owner;
    }
}

public class CarMain{
   public static void main(String[] args) {
      Car car1 = new Car(new Owner());
      // 혹은
      Owner owner2 = new Owner();
      Car car2 = new Car(owner2);
   }
}
```
이상의 코드는 서비스 객체가 클라이언트 클래스에서 직접 생성되지 않습니다. 대신 클래스 생성자에서 매개변수로 전달되는 예시입니다.

여기서 Client class가 Car고 의존성에 해당하는 것이 Owner라는 점에 유의하시고 해석하시기 바랍니다.

또한 서비스 클래스는 추상 클래스일 수도 있습니다. 이 경우 클라이언트 클래스에서 해당 클래스의 어떤 구현이든 이용할 수 있고, 테스트 중에는 Mock을 이용할 수도 있습니다.

의존성 주입에도 마찬가지로 유형이 있습니다.
## 의존성 주입 유형
1. 생성자(Constructor) 주입 : 의존성이 클라이언트 클래스 생성자에게 전달되는 방식. 생성자 주입의 예시는 앞의 Car 코드에서 확인 가능합니다. 생성자 주입은 필수 의존성에 이용하는 것이 좋습니다. 모든 의존성은 클래스 생성자를 이용하여 제공되며 필수 의존성 없이는 객체를 생성할 수 없습니다(즉 매개변수 생성자를 이용하라는 의미입니다).

2. 세터(Setter) 주입 : 의존성이 세터를 통해 제공되는 방식입니다. 이하의 코드를 확인하겠습니다.
```java
public class Car {
    private Owner owner;
    
    public void setOwner(Owner owner) {
        this.owner = owner;
    }
}
```
이상의 세터 주입은 아무런 의존성이 없더라도 객체를 생성할 수 있기 때문에 더 유연합니다. 이 접근 방식은 선택적 의존성을 허용해줍니다.

의존성 주입은 코드의 의존성을 줄이고 코드를 _재사용하기 쉽게_ 만들어줍니다.
이제 스프링부트 상에서의 의존성 주입 부분을 학습할겁니다.

## 스프링 부트에서의 의존성 주입 이용
스프링 프레임워크에서 의존성 주입은 스프링 ApplicationContext를 통해 이루어집니다. 이는 객체(빈bean)와 객체의 의존성을 생성하고 관리하는 역할.

스프링 부트 애플리케이션 클래스를 검색하여 특정 애너테이션(@Service / @Repository / @Controller 등)이 있는 클래스를 스프링 빈으로 등록합니다. 의존성을 주입하면 이러한 빈을 주입할 수 있습니다.

아까 배운 생성자 주입 / 세터 주입 / 필드 주입 방식을 스프링부트 버전으로 풀어서 쓰겠습니다.


1. 생성자 주입
   - 생성자를 통해 의존성을 주입. 이 방법은 객체가 생성될 때 필요한 모든 의존성을 반드시 이용하게 하므로 가장 권장되는 방법입니다. 가장 보편적인 상황은 특정 작업을 위해 DB에 대한 접근이 필요한 경우입니다. 스프링부트에서는 이를 위해 repository 클래스를 이용합니다.
```java
public class Car {
    private final CarRepository carRepository;
    
    public Car(CarRepository carRepository) {
        this.carRepository = carRepository;
    }
    // DB 상에서 CarRepository에 있는 모든 자동차 목록을 가져옴.
   carRepository.findAll(); // SELECT * FROM car;
   carRepository.findOwners(); // SELECT owner FROM car;
}
```
여기서 중요한 것 중 하나는 .findAll();이라는 메서드가 메서드명이 고정되어있다는 점입니다.

근데 클래스에 생성자가 여러 개 있는 경우 `@AutoWired` 애너테이션을 이용하여 의존성 주입에 이용되는 생성자를 정의해야 합니다.

```java
public class Car {
    private final CarRepository carRepository;

    //의존성 주입에 이용하는 생성자
   @AutoWired
    public Car(CarRepository carRepository) {
        this.carRepository = carRepository;
    }
}
```
2. 세터 주입 : 의존성은 세터 메서드를 통해 주입됩니다. 세터 주입은 선택적 의존성이 있거나 런타임(프로그램 실행 중)에 의존성을 수정하려는 경우에 유용합니다.
```java
@Service
public class AppUserService {
    // 필드 정의
    private AppUserRepository userRepository;
    
    @AutoWired
    public void setAppUserRepository(AppUserRepository userRepository) {
        this.userRepository = userRepository;
    }
     // 이상의 코드 그냥 일반적인 setter라고 볼 수 있습니다. call2() 유형이죠.

    // 그러면 이제 userRepository를 이용한 다른 메서드들을 여기서 사용할 수 있죠.
    // 저희가 volumeUpButton을 이용했던 것처럼요.
    // userRepository.findAll();로 전체 목록을 불러와서, 전체 user 숫자를 카운트한다든지 등.
}
```

3. 필드 주입 : 의존성을 필드에 직접 주입합니다. 가장 단순하긴 한데, 의존성을 사용할 수 없는 경우에 런타임 에러가 발생할 수 있고, 테스트를 위해서 모의 객체를 만드는게 아니라 그때그때 새로운 객체가 만들어지기 때문에 테스트하기가 좀 어렵습니다.
```java
// 필드 주입
@Service
public class CarDatabaseService implements CarService {
    // 여기에 어쩌고 Car 데이터베이스 서비스가 있다고 가정하겠습니다.
}

public class CarController {
    @Autowired                  // 여기가 좀 중요합니다.
   private CarDatabaseService carDatabaseService;
}
```

# JPA를 이용한 데이터베이스 생성 및 접근
Springboot와 함께 JPA(Jakarta Persistence API / Java Persistence API)를 이용하는 방법 및 Entity 클래스로 데이터베이스를 정의하는 방법을 학습하겠습니다(SQL로는 할 수 있었죠).

H2 인메모리 데이터베이스라는 개념을 학습할겁니다. 그리고 H2에서 MariaDB로 이동을 시킬겁니다. 동시에 CRUD Repository를 생성하고, 데이터베이스의 테이블과 엔티티 클래스의 관계에 대해 학습하겠습니다.

## ORM / JPA / Hibernate 개념
ORM / JPA는 RDB를 처리하기 위해 소프트웨어 개발에서 널리 이용되는 기술로, 복잡한 SQL 쿼리를 작성할 필요 없이 Java 개발자에게 친숙한 객체 형태로 DB를 조작할 수 있습니다. ORM / JPA는 SQL 코드 작성 및 디버깅에 소요되는 시간을 줄여줍니다.

근데 우리는 Java는 좀 까먹었고 지난 금요일에 SQL 쳤으니까 SQL도 까먹었겠네요.
대부분의 JPA 구현체들은 Java Entity 클래스를 바탕으로 DB의 스키마를 자동으로 생성할 수 있습니다.

1. ORM(Object Relational Mapping) : 객체지향 프로그래밍 패러다임을 이용하여 DB를 가져오고 매핑할 수 있는 기술. ORM은 데이터베이스 구조보다는 객체지향 개념을 바탕에 두고 있어서 Java 개발자가 굳이 SQL까지 배울 필요성을 줄여준다는 점에서 장점이 있습니다. 그리고 장점은 ORM으로 개발하게 되면 DB와는 독립적으로 구동되기 때문에 개발자가 이용하는 DBMS가 무엇인지에 따라 달라지는 SQL 문에 대해 걱정할 필요가 없습니다. -> 즉 DB이식이 좀 쉽습니다.

2. JPA : Java 개발자를 위한 객체-관계형 매핑을 제공(ORM의 더 구체적인 버전이라고 생각하시면 됩니다). JPA 엔티티는 데이터베이스 테이블의 구조를 나타내는 Java 클래스에 해당합니다(이미 수업했습니다). 엔티티 클래스의 필드는 데이터베이스 테이블의 Column을 나타냅니다.

3. Hibernate : 최근에 가장 인기있는 JPA 구현체이고, 스프링 부트에서 기본 구현체로 이용됩니다. 대규모 애플리케이션에서 자주 쓰입니다.


## 엔티티 클래스(Entity)
JPA에서 @Entity 애너테이션을 이용하는 Java 클래스로, 표준 Java bean 명명 규칙도 따르고, 적절한 getter / setter 메서드도 가집니다. 그리고 private으로 설정합니다.

얘는 애플리케이션이 초기화될 때 _클래스 이름으로 데이터베이스의 테이블을 생성_ 합니다. 만약에 다른 이름으로 지정하고 싶으면 엔티티 클래스에 @Table 애너테이션을 별개로 달 수 있는데, 이는 추후 수업하겠습니다.

그럼 알 수 있는 거 -> 
1. field 명이 column명이 된다.
2. class 명이 table명이 된다.


H2 데이터베이스 / JPA 이용을 위해 build.gradle을 수정하겠습니다.
수정 전
```java
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```
수정 후
```java
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'  추가
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	runtimeOnly 'com.h2database:h2'                                         추가
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```
Car Entity class
```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    private String brand, model, color, registrationNumber;

    private int modelYear, price;
}
```
1. @Id : DB에서의 테이블의 Primary Key에 해당하는 field에 달아주는 애너테이션(그럼 DB에서의 기본 키 개념을 명확히 아셔야겠네요).
2. @GeneratedValue : 데이터베이스가 자동으로 ID를 생성하도록 지정(ID값을 우리가 객체 생성할 때 일일이 넣지 않는다는 것을 의미합니다. 다른 키 생성 전략을 사용할 수도 있습니다.). AUTO는 JPA 공급자가 특정 데이터베이스에 가장 적합한 전략을 선택한다는 의미로, default값입니다.

- DB에서의 column명은 기본적으로 클래스 필드 명명 규칙에 따라 지정됩니다. 그래서 다른 컬럼명으로 지정하고 싶다면 @Column 애너테이션을 활용하여 커스텀할 수도 있습니다. 또한,

3. @Column : 컬럼명을 사용자화 / 컬럼의 길이 / 컬럼의 nullable 여부를 지정하는 것도 가능합니다. 예시는 이하와 같습니다.
```java
@Entity
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
   private Long id;
    
    @Column(name="explanation", nullable=false, length=512)
   private String description;
}
```
즉, Car 클래스의 description 필드는 car 테이블에서는 explanation이라는 컬럼명을 갖게 되고, VARCHAR(512)로 데이터 길이가 지정되었으며, null 불가라는 의미를 지니게 됩니다.

application.properties에 이제 h2 인메모리 DB를 사용할거라는 걸 적어줘야합니다.

```properties
spring.application.name=cardatabase
spring.datasource.url=jdbc:h2:mem:testdb
spring.jpa.show-sql=true
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console
```
chrome에서
localhost:8080/h2-console
이라고 접속하게 되면

이상까지의 상황에서 나타난 수강생 분들의 오류 모음
1. domain 패키지가 test 내에 있었던 경우에는 실행은 됐으나 sql 문이 실행되지 않았습니다.
2. application.properties에서 오타가 있었습니다. show-sql인데 show-spl이라든지 etc...
   - 이상의 경우들에서 생기는 문제점은 실행은 된다는 점입니다. 근데 생각한 결과값이 콘솔에 안찍히게 되죠. 그래서 폴더 구조도 신경쓰도록 하겠습니다.

## CRUD repository 생성
Spring Data Jpa에는 CRUD 작업을 위한 CrudRepository라는 인터페이스가 있습니다. 해당 인터페이스는 엔티티 클래스에 CRUD 기능을 제공합니다.

1. domain 패키지에 interface인 CarRepository를 생성.
```java
package com.example.cardatabase.domain;

import org.springframework.data.repository.CrudRepository;

public interface CarRepository extends CrudRepository<Car, Long> {
}
```
CarRepository는 스프링부트 JPA의 CrudRepository 인터페이스를 바탕으로 확장된 클래스입니다(상속받았으니까 부모 클래스의 필드/메서드를 사용할 수 있죠. 근데 둘 다 인터페이스니까 추상 메서드들을 상속받았다고 볼 수 있겠습니다). 그리고 `<Car, Long>` 타입의 argument는 Car 엔티티 클래스의 리포지토리이고, id 필드의 타입이 Long임을 명시했습니다. 이상의 제네릭으로 인해서 Car - CarRepository 관계가 Entity - Repository 관계로 성립됩니다.

CrudRepository 인터페이스에는 당연히 추상 메서드들이 있을겁니다. 일반적으로 사용되는 메서드 목록을 명시하겠습니다.

### CrudRepository의 추상 메서드 소개
1. long count() - 엔티티의 수를 반환
2. Iterable<T> findAll() - 지정한 타입의 모든 항목을 반환                                            - Read
3. Optional<T> findById(ID id) - 지정한 ID의 한 항목을 반환(JS에서 getElementById()생각하시면 됩니다)  - Read
4. void delete(T entity) - 엔티티 삭제                              - Delete
5. void deleteAll() - 리포지토리 내의 모든 엔티티를 삭제              - Delete
6. `<S extends T>` save(S entity) - 엔티티를 저장                   - Create  
7. `List<S>` saveAll(`Iterable<S>` entities) - 여러 엔티티를 저장    - Create

method가 한 항목만 반환할 때는 T 대신에 `Optional<T>`를 반환합니다. Optional 클래스는 Java 8 SE에서 처음 도입된 타입으료, 값을 포함하거나 포함하지 않는 단일 값 컨테이너입니다(특정 id값이 없는 경우에 보통 메서드 결과값이 오류로 발생하기 때문에 이를 막는 용도로 Optional을 사용합니다). 값이 있으면 isPresent() 메서드가 true를 반환하고, 없으면 false를 반환합니다. 그리고 값이 있을 때만 get() 메서드를 통해 값을 얻게 됩니다.

해당 Optional을 사용하게 되면 NullPointerExcpetion을 방지할 수 있습니다.

2. 이제 H2 인메모리에 예제 데이터들을 집어넣겠습니다. 인메모리 DB는 실행될 때마다 DB를 새로 만들고, 종료될 때 삭제하기 때문에 현재 h2-console에서 값을 입력해봤자 껐다 키면 없어집니다. 이를 방지하기 위해서 Springboot 프로젝트 내에 예제 데이터를 집어넣도록 할 겁니다.

CommandLineRunner 인터페이스를 사용. -> 애플리케이션이 완전히 시작되기 전에 특정 코드를 실행할 수 있음.
CarDatabaseApplication에 CommandLineRunner를 구현합니다.
```java
package com.example.cardatabase;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication implements CommandLineRunner {
	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
	}

	@Override
	public void run(String... args) throws Exception {

	}
}
```
다음, 새로운 Car 객체를 데이터베이스에 저장할 수 있도록 CarRepository를 main 클래스에 주입할겁니다. 생성자 주입 개념을 통해서 CarRepository를 주입하겠습니다.

```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    private String brand, model, color, registrationNumber;

    private int modelYear, price;

    // JPA는 기본 생성자가 필수적으로 요구됩니다.
    public Car() {}

    public Car(String brand, String model, String color, String registrationNumber, int modelYear, int price) {
        this.brand = brand;
        this.model = model;
        this.color = color;
        this.registrationNumber = registrationNumber;
        this.modelYear = modelYear;
        this.price = price;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public String getRegistrationNumber() {
        return registrationNumber;
    }

    public void setRegistrationNumber(String registrationNumber) {
        this.registrationNumber = registrationNumber;
    }

    public int getModelYear() {
        return modelYear;
    }

    public void setModelYear(int modelYear) {
        this.modelYear = modelYear;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }
}
```

Car entity 클래스에서 기본 생성자 삭제 했고, getter / setter도 삭제했습니다.
해당 부분을 Lombok 라이브러리의 도입을 통해서 오류를 해결하고자 합니다.

해결하시오.

1. intellij상에 plugin에 롬복이 깔려있는지 체크
   - ctrl + alt + s 눌러서 설정으로 들어가서 plugins 혹은 플러그인을 클릭합니다.
2. chrome에서 mvn 검색 -> lombok 검색 -> version 최신 버전 받으시면 됩니다.
    - groovy short인지 확인해야 합니다(근데 사실 long도 됩니다).
3. build.gradle 가서 dependencies에
   implementation 'org.projectlombok:lombok:1.18.42' 이거 붙여넣습니다.
4. 근데 annotationProcessor 'org.projectlombok:lombok:1.18.42' 도 붙여넣습니다.

그 결과는

```java
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	runtimeOnly 'com.h2database:h2'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
    // 롬복 관련 의존성
	implementation 'org.projectlombok:lombok:1.18.42'
	annotationProcessor 'org.projectlombok:lombok:1.18.42'
}
```
그리고 파란색 코끼리를 꼭 눌러주셔야합니다.

Spring Data Repository에 쿼리를 정의하는 것도 가능합니다.(SQL을 의미하는 게 아닙니다. SQL로도 쓸 수는 있어요) 쿼리는 접두사(prefix : findBy 등)로 시작해야하고, 그 다음에는 쿼리에 이용할 엔티티 클래스 필드를 정의해야 합니다.

그러면 main에 
```java
System.out.println(repository.findByBrand('Kia'));
```
라고 작성했을 경우 콘솔 창에
`[Car(id=1, ...,)]`과 같은 형태로 나오게 됩니다.
근데 이렇게 안나오시는 분들은 아마 Car 엔티티 클래스에 `@Data`가 아니라 `@Getter`, `@Setter`를 애너테이션 달아놨기 때문에 `@ToEntity`애너테이션 효과가 없어서 객체의 주소값만 나왔을 수도 있습니다.

CarRepository에 색상으로 자동차들을 검색할 수 있도록 메서드를 정의하고 main에 White 색을 호출하여 콘솔창에 표시하시오.

CarRepository에 연도로 자동차들을 검색할 수 있도록 메서드를 정의하고 main에 2024 로 호출하여 콘솔창에 표시하시오.

```java
package com.example.cardatabase.domain;

import org.springframework.data.repository.CrudRepository;

import java.util.List;

public interface CarRepository extends CrudRepository<Car, Long> {
    // 브랜드로 자동차를 검색
    List<Car> findByBrand(String brand);

    // 색상으로 자동차를 검색
    List<Car> findByColor(String color);
    // 연식으로 자동차를 검색
    List<Car> findByModelYear(int modelYear);

    // 브랜드와 모델을 합쳐서 자동차를 검색
    List<Car> findByBrandAndModel(String brand, String model);

    // 브랜드 또는 색상별로 자동차를 가져오기
    List<Car> findByBrandOrColor(String brand, String color);

    // 브랜드로 자동차를 검색하고 연도로 정렬
    List<Car> findByBrandOrderByModelYearAsc(String brand);
}
```
`@Query` 애너테이션을 사용하면 직접 SQL문을 작성함으로써 쿼리 메서드를 만드는 것도 가능합니다. 근데 이름은 또 어차피 고정되어있습니다.
```java
    @Query("select c from Car where c.brand = ?1")
    List<Car> findByBrand(String brand);
```
근데 지금 확인해보시면 어차피 @Query가 있으나 없으나 List 부분은 똑같이 작성되는 것을 알 수 있습니다. 그런데 어떨 때 쓰냐면 엄청 복잡한 쿼리를 작성해야 할 때이거나, 아니면
LIKE와 같은 고급 표현식을 사용할 때 적용할 수 있습니다.
우리가 처음 작성한 방식대로라면
```java
System.out.println(repository.findByBrand("Kia"));
```
로 완벽하게 작성해야지만 튀어나옵니다.
```java
System.out.println(repository.findByBrand("Ki"));
```
이렇게 쓰면 Ki라는 brand가 존재하지 않는다면 아예 결과값이 나오지 않게 됩니다. 하지만 @Query를 사용하게 될 경우에는 LIKE를 적용할 수 있기 때문에 578 번 라인과 같이 작성하더라도 brand가 Kia인 애들이 결과값에 튀어나오게 됩니다.

```java
    // SQL문을 활용한 브랜드로 자동차 검색
    @Query("select c from Car c where c.brand = ?1")
    List<Car> findByBrand(String brand);

    // SQL을 활용한 브랜드로 자동차를 검색하는데 부분 검색을 적용
    @Query("select c from Car c where c.brand like %?1")
    List<Car> findByBrandEndsWith(String brand);

    @Query("select c from Car c where c.brand like ?1%")
    List<Car> findByBrandStartsWith(String brand);
```

Spring Data JPA에서는 CrudRepository로부터 확장된 PagingAndSortingRepository도 있습니다. 이 인터페이스는 페이징 및 정렬을 통해 엔티티를 검색하는 메서드를 제공합니다. 이 경우 대규모 결과 집합에서 모든 데이터를 반환할 필요가 없기 때문에 대규모 데이터를 처리하기에 적합합니다.
```java
package com.example.cardatabase.domain;

import org.springframework.data.repository.PagingAndSortingRepository;

public interface CarRepository extends PagingAndSortingRepository<Car, Long> {
}
```
제공하는 메서드
1. Iterable<T> findAll(Sort sort) - 지정된 옵션으로 정렬된 모든 엔티티를 반환
2. Page<T> findAll(Pagable pagable) - 지정한 페이징 옵션으로 모든 엔티티를 반환

근데 결과적으로 우리는 뭐 쓸거다? JpaRepository 쓸거다.

## 테이블 간의 관계 추가
car 테이블과 일대다(1:N) 관계에 있는 owner라는 새 테이블을 만들겁니다. 일대다 관계는 소유자가 한 명이 자동차 여러 대를 가질 수 있지만, 한 자동차의 소유자는 한 명이라는 의미입니다.

domain 패키지에 Owner이라는 엔티티 클래스와 OwnerRepository라는 repository 인터페이스를 만들어야 합니다. 그리고 OwnerRepository는 JpaReposiotry를 상속 받아야 합니다.

git add .
git commit -m "feat : 20250922 springboot entity / repository"
git push