# CORS Filter 추가하기
- CORS(Cross-Origin Resources Sharing) : 클라이언트와 서버가 교차 출처 재요청을 허용할지 거부할지를 결정하게 하는 특정 헤더를 가짐.
- CORS filter는 다른 출처에서 요청을 보내는 프론트엔드와의 통신에서 필요합니다.
- 프론트엔드 상에서 특정 요청이 백엔드로 넘어가게 되는 과정에서 CORS 필터가 요청을 중간에 확인하여, 교차 출처로 식별되면 요청에 적절한 헤더를 추가하여 서로 통신을 주고 받을 수 있도록 허용해줍니다.
- CorsConfigurationSource 인터페이스를 사용합니다.
- 현재까지의 예제에서는 모든 출처의 HTTP 메서드와 헤더를 허용하는 상태입니다.

1. SecurityConfig 클래스를 수정합니다.
수정전
```java
package com.example.cardatabase;

import com.example.cardatabase.service.UserDetailsServiceImpl;
import com.example.cardatabase.AuthenticationFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;
    private final AuthenticationFilter authenticationFilter;
    private final AuthEntryPoint exceptionHandler;

    public SecurityConfig(UserDetailsServiceImpl userDetailsService, AuthenticationFilter authenticationFilter, AuthEntryPoint exceptionHandler) {
        this.userDetailsService = userDetailsService;
        this.authenticationFilter = authenticationFilter;
        this.exceptionHandler = exceptionHandler;
    }

    public void configGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeRequests -> authorizeRequests.requestMatchers(HttpMethod.POST, "/login").permitAll().anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }
}
```

추가 버전
```java
package com.example.cardatabase;

import com.example.cardatabase.service.UserDetailsServiceImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;
    private final AuthenticationFilter authenticationFilter;
    private final AuthEntryPoint exceptionHandler;

    public SecurityConfig(UserDetailsServiceImpl userDetailsService, AuthenticationFilter authenticationFilter, AuthEntryPoint exceptionHandler) {
        this.userDetailsService = userDetailsService;
        this.authenticationFilter = authenticationFilter;
        this.exceptionHandler = exceptionHandler;
    }

    public void configGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeRequests -> authorizeRequests.requestMatchers(HttpMethod.POST, "/login").permitAll().anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(Arrays.asList("*"));
        config.setAllowedMethods(Arrays.asList("*"));
        config.setAllowedHeaders(Arrays.asList("*"));

        config.setAllowCredentials(false);
        config.applyPermitDefaultValues();

        source.registerCorsConfiguration("/**", config);
        return source;
    }
}
```
// 특정 Origin 만을 명시적으로 정의하려면
`config.setAllowOrigins(Arrays.asList("http://localhost:5173", "http://localhost:3000"))`
과 같이 사용할 수 있습니다. 어차피 5173일거니까 ctrl + f로 5173 검색해두세요.
2. SecurityConfig를 수정했으니 filterChain 관련 method도 수정해야합니다.

```java
import static org.springframework.security.config.Customizer.withDefaults;

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.csrf(csrf -> csrf.disable())
            .cors(withDefaults())
            .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authorizeRequests -> authorizeRequests.requestMatchers(HttpMethod.POST, "/login").permitAll().anyRequest().authenticated())
            .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(exceptionHandler));
    return http.build();
}
```

# Role-Based Protection
- Spring Security는 역할을 이용하여 세분화된 역할 기반 보안을 정의할 수 있으며, 사용자는 하나 또는 여러 역할에 할당되어질 수 있다. 역할은 흔히 ADMIN / MANAGER / USER와 같은 계층 구조를 가지게 되는데 USER가 할 수 있는 모든 일은 MANAGER가 다 할 수 있으면서 MANAGER는 USER보다 더 많은 접근 권한을 가지고, ADMIN은 MANAGER가 할 수 있는걸 또 다 할 수 있으면서 지만 할 수 있는 다른 접근 권한을 갖는 등으로 생각하시면 되겠습니다.

SecurityConfig 클래스의 요청 수준에서 역할 기반 접근 제어를 정의할 수 있습니다. 이하의 예제 코드에서는 접근을 위한 특정 역할이 필요한 엔드포인트를 정의할겁니다. `/admin/**` 엔드포인트에 접근하려면 ADMIN 역할이 필요하고, `/user/**` 엔드포인트에 접근하려면 USER 역할이 필요한 등이 되겠습니다. 사용자가 지정된 역할을 가지고 있으면 true를 반환하는 Spring Security hasRole() 메서드를 이용합니다.


Role-Based Protection 적용 filterChain 예시(예제 프로젝트에는 도입하지 않습니다.)
```java
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .cors(withDefaults())
                .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeRequests -> 
                  authorizeHttpRequests.requestMatches("/admin/**").hasRole("ADMIN").requestMatchers("/user/**").hasRole("USER").anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }
```
Spring Security는 Method 수준의 보안을 적용하는 데 이용되는 `@PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter, @Secured` 에너테이션들이 있습니다. 메서드 수준 보안은 default로 spring-boot-starter-security에서 이용하도록 설정되어 있지 않습니다. 스프링 구성 클래스(최상위-저희 기준으로 CarDatabaseApplication)에서 `@EnableMethodSecurity` 에너테이션을 이용하여 활성화해야하는데...
예시로 남겨두지는 않겠습니다.

# BackEnd Tests
git add .
git commit -m "feat: backend protection finished"
git push

cardatabase_3_test 프로젝트로 복사하겠습니다.

## Tests In SpringBoot
Springboot test starter 패키지는 프로젝트 생성할 때 Spring initializr에 의해 자동으로 build.gradle에 추가됩니다.
```java
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
```
위에 얩니다.
spring-boot-starter-test는 JUnit / Mockito / AssertJ 같은 테스트 관련 라이브러리를 제공합니다. Mockito 모의 테스트 프레임워크로 JUnit과 함께 자주 이용됩니다. AssertJava 테스트에서 Assertion을 작성하는데 이용되는 라이브러리입니다.

기본적으로 테스트 시에는 인메모리데이터베이스를 사용합니다. 지금 저희는 MariaDB를 사용하고 있기는 한데, test용으로 다시 h2 인메모리를 적용할 예정입니다.

```java
    testRuntimeOnly 'com.h2database:h2'
```
이상까지 처리하고 코끼리 눌러주면, 애플리케이션에 대한 테스트 케이스를 만드는 것이 가능합니다.

## 테스트 케이스 생성
테스트 케이스의 유형들
1. 단위 테스트(Unit Test) : 소프트웨어의 가장 작은 컴포넌트에 초점을 맞춘다. 예를 들어 함수에 초점을 맞춘다면, 단위 테스트는 함수가 독립적으로 올바르게 작동하는지를 확인한다. 단위 테스트에서 Mocking은 테스트 중인 단위의 의존성을 대체하기 위해 흔히 사용되는 개념.

2. 통합 테스트(Integeration Test) : 개별 컴포넌트 간의 상호작용에 중점을 두어 개별 컴포넌트가 예상대로 _함께_ 작동하는지 확인.

3. 기능 테스트(Functional Test) : 기능 사양에 정의된 비지니스 시나리오에 중점을 둔다. 테스트케이스는 소프트웨어가 제시된 _요구 사항_ 을 충족하는지 확인하기 위해서 설계됨.

4. 회귀 테스트(Regression Test) : 새로운 코드 또는 코드 업데이트가 기존 기능을 손상시키지 않는지 확인하는 것을 목적으로 함.

5. 이용성 테스트(Usability Test) : 최종 사용자의 관점에서 소프트웨어가 사용자 친화적이고 직관적이며 이용하기 쉬운지 검증하는 것을 목표로 함. 프론트엔드 및 사용자경험(UX)에 더 중점을 두는 편.

이하는 SpringBoot Test 클래스의 예시에 해당합니다.

```java
@SpringBootTest
public class MyTestClass {

  @Test
  public void testMethod() {
    // 테스트 케이스 로직
  }
}
```
- `@SpringBootTest` 애너테이션은 클래스를 스프링부트 기반 테스트를 실행하는 일반 테스트 클래스로 지정하는 용도.

- `@Test` 애너테이션은 메서드가 테스트 케이스로 실행되도록 JUnit에 지정하는 용도.

- Mocking : 테스트 대상 객체가 다른 객체나 외부 서비스에 의존하는 경우에 실제로 다른 객체 및 외부 서비스를 이용하지 않고 가짜 객체 (Mock Objec)로 대체하는 것을 의미함. Mocking을 이용하면 테스트 대상 객체의 작동을 독립적으로 검증할 수 있으며, 외부 의존성으로 인한 테스트 불확실성과 복잡성을 해소할 수 있음.

```java
public void methodA() {
  // 어쩌고 비지니스 로직
}

public String methodB() {
  String result = "";
  methodA();
  // 어쩌고 비지니스 로직

  return result;
}
```

Assertion은 코드 단위에서의 실제 출력이 예상 출력과 일치하는지를 확인하는 데 이용하는 구문으로, spring-boot-starter-test 아티팩트에 자동으로 포함되는 AssertJ 라이브러리를 활용하여 구현합니다.
assertThat() 메서드를 제공하는데, 이 메서드 내에 객체 혹은 값을 전달헀을 때 실제 출력값과 비교를 할 수 있습니다.
assertThat() 은 자료형에 따라 여러 방식으로 구현할 수 있는데 , 예시는 이하와 같습니다.
```java
// 문자열 확인
assertThat("Learn Spring Boot").startsWith("Learn");

// 객체 확인
assertThat(myObject).isNotNull();

// 정수 확인
assertThat(myNumberVariable).isEqualTo(3);

// Boolean 확인
assertThat(myBooleanVariable).isTrue();
```

Controller의 인스턴스가 올바르게 생성되고 null이 아닌지 확인하는 단위 테스트 케이스를 만들어볼겁니다.
현재 CarDatabaseApplicationTests 클래스를 확인해보면 이하와 같습니다.
```java
package com.example.cardatabase;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class CardatabaseApplicationTests {

	@Test
	void contextLoads() {
	}

}
```
확인해보시면 내부에 contextLoads라는 테스트 메서드가 하나 있고, 여기에 텍스트를 추가할 겁니다. Controller의 인스턴스가 성공적으로 생성되고 주입되었는지 확인하는 코드를 작성할겁니다. 그리고 주입된 인스턴스가 null인지 아닌지의 여부를 확인하기 위해 assertThat을 도입하겠습니다.

## @Autowired
- 정의
  Spring Framework에서 _의존성 주입(Dependency Injection, DI)_ 을 수행할 때 사용하는 _핵심 애너테이션_ 입니다. 개발자가 직접 객체를 생성하고 연결하는 대신 Spring Container가 필요한 객체를 찾아 자동으로 연결(주입)해주도록 지시합니다.

- 특징 및 작동 방식
  1. 의존성 주입(DI)
    - 특정 클래스가 필요로 하는 다른 클래스(의존성)의 인스턴스를 외부에서 제공받는 디자인 패턴 구현체. `@Autowired`를 사용하면 Spring이 이 주입 과정을 알아서 처리함.
  2. 자동 연결
    - Spring 컨테이너는 `@Autowired`가 붙은 field, 생성자, 메서드를 발견하면 컨테이너 내부에 관리하고 있는 _적절한 타입_ 의 Bean을 찾아 자동으로 연결해줍니다.
  3. 타입 기반 탐색
    - 기본적으로 Spring은 주입 대상의 _Type_ 을 기준으로 컨테이너에서 일치하는 bean을 찾아냅니다. 만일 동일 타입의 빈이 여러 개 발견되면 `@Qualifier` 애너테이션을 사용하여 빈의 _이름_ 으로 명호가하게 지정해야 함.

  4. 필수(Required) 설정 
    - 기본적으로 의존성 주입은 필수(required = true)인데, 만약 주입할 빈이 컨테이너에 없을 경우 애플리케이션 시작 시 오류가 발생합니다(어제 저희가 `@Component` 안달아서 오류 났었습니다). required = false 설정하면 주입할 빈이 없어도 허용됩니다.

- 의존성 주입 위치 (Injection Position)
  - `@Autowired` 클래스 내 세 군데에 위치가 가능하며, 최신 Spring에서는 생성자 주입을 권장함(우리가 계속 해왔습니다).

  1. field 주입 - 가장 지양되는 방식 : 간단하긴 한데 객체의 불변성을 보장하기 어렵고 테스트가 불편해서 비권장됩니다.
```java
@Service
public class MyService {
  @Autowired
  private UserRepository userRepository;
  // 생성자 / 메서드 어쩌고저쩌고
}
```
  2. Setter 메서드 주입(Setter injection) - 선택전 의존성을 주입할 때 주로 사용되며, 객체 생성 후 주입이 이루어짐.

```java
@Service
public class MyService {
  private UserRepository userRepository;

  @Autowired
  public void setUserRepository(UserRepository userRepository) {
    this.userRepository = userRepository;
  }
}
```
  3. 생성자 주입(Contructor Injection) - 가장 권장되는 방식. 객체의 불변성을 보장하고 누락된 의존성을 명확하게 알 수 있어 가장 안전하고 권장됨. 근데 이게 저히가 생성자 주입할 때 @Autowired를 안쓴게 Spring 4.3 이후 부터는 클래스 내에 _생성자가 하나만_ 존재한다면 `@Autowired`를 생략해도 자동으로 주입됩니다.

```java
@RestController
@RequierdArgsConstructor
public class LoginController {
  private final JwtService jwtService;      //final을 통한 불변성 보장 - 그리고 생성자 강제
  private fianl AuthenticationManager authenticationManager;

  public LoginController(JwtService jwtService, AuthenticationManager authenticationManager) {
    this.jwtService = jwtService;
    this.authenticationManager = authenticationManager;
  }
}
```
CarController가 현재 상황에서 컨테이너에 등록되어있는지에 대한 여부. 
쟤가 CarDatabaseApplicationTests 클래스에서 `@Autowired`로 끌고 올 수 있는 이유는 간단하게 `@SpringBootTest` 애너테이션 때문입니다.
테스트 환경에서는 기존 CarDatabaseApplication에 있는 전체 환경을 로드하여 테스트를 진행하기 때문에,  그 설정에 맞추서 IoC 컨테이너를 생성하게 됩니다. 그래서 거기서 생성된 모든 컴포넌트(Controller / Service / Repository 등)를 full scan 하여 Bean 등록을 하게 됩니다.

이상을 이유로 CarController 클래스에 있는 `@RestController`가 있다면 `@SpringBootTest` 가 컨테이너를 로드하는 과정에서 Bean으로 등록됩니다.

이제 기본적인 단위 테스트 학습을 마쳤기 때문에 OwnerRepository에 대한 통합 테스트를 만들어서 CRUD(Create / Read / Update / Delete) 관련 작업을 테스트할 겁니다. 이 테스트는 리포지토리가 데이터베이스와 올바르게 상호작용하는지를 검증할거고, 이 과정에서 개발자의 예상대로 올바르게 작동하는지를 확인하는 부분이 될겁니다.

1. root 테스트 패키지에서 OwnerRepositoryTest라는 새 클래스를 생성할겁니다. 테스트가 JPA 컴포넌트에 초점을 맞추게 될 경우에는 `@SpringBootTest` 애너테이션 대신에 `@DataJPATest` 애너테이션을 이용할 수 있습니다. 얘를 쓰면 H2 인메모리 데이터베이스와 스프링 데이터가 테스트를 위해서 자동으로 구성되고, SQL 로깅(콘솔에 찍히는 것) 도 켜집니다.

```java
package com.example.cardatabase;

import com.example.cardatabase.domain.OwnerRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;

@DataJpaTest
class OwnerRepositoryTest {
    @Autowired
    private OwnerRepository ownerRepository;
}
```

이상의 코드에서 field 주입 형태로 `@Autowired`가 적용된 것도 확인할 수 있습니다.
이제 DB에 새 Owner 추가를 테스트하기 위한 테스트 케이스를 추가할 예정인데, 자동 생성 말고 OwnerRepository 상에서 이용할 쿼리 메서드 좀 추가하겠습니다.
```java
Optional<Owner> findByFirstName(String firstName);
```

이번에는 DB에서 Owner 하나를 삭제할겁니다. 근데 우리가 H2인 메모리인 상황에서 CardatabaseApplication에서 작성한 더미 데이터가 적용된다는 것을 알았기 때문에 일단 새 Owner 하나를 추가해서 넣고, 그 다음에 전체 목록을 다 삭제하는 부분을 작성하겠습니다.

중요한 부분은 테스트 코드 라인이 어떤식으로 이루어졌나입니다.
```java
@Test
@DisplayName("삭제 테스트 : ")
void deleteOwners() {
  // 그러면 일단 객체 생성을 하나 해서 repository에 저장할겁니다.
  ownerRepository.save(new Owner("팔백", "박"));
  // 삭제 method 호출
  ownerRepository.deleteAll();
  // 삭제 완료되었는지를 체크하는 assertThat()문이 필수적으로 요구됩니다.
  assertThat(ownerRepository.count()).isEqualTo(0);
}
```

1. 루트 테스트 패키지에서 CarRestTest 클래스를 생성할겁니다. Controller 또는 노출된 엔드포인트를 테스트하기 위해서는 MockMvc 객체를 이용할 수 있습니다. MockMvc 객체를 이용하면 서버가 시작되지는 않지만 Spring 자체에서 HTTP 요청을 처리하는 계층에서 테스트가 수행되므로 실제와 유사하게 상황을 재현할 수 있습니다. 그래서 MockMvc 내에는 요청을 전송하는 Performance Methods를 제공해줍니다. Authentication 관련 테스트를 하려면 요청 본문에 자격 증명을 추가해야 합니다. .andDo() 메서드를 이용하여 요청 및 응답 세부 정보를 console에 출력하고, .andExpect() 메서드를 활용하여 응답 

```java
package com.example.cardatabase;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.HttpHeaders;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@AutoConfigureMockMvc
public class CarRestTest {
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    @DisplayName("자격증명인증테스트")
    public void testAuthentication() throws Exception {
        this.mockMvc.perform(post("/login")
                .content("{\"username\":\"admin\",\"password\":\"admin\"}")
                .header(HttpHeaders.CONTENT_TYPE, "application/json"))
                .andDo(print()).andExpect(status().isOk());
    }
}
```
식사 전 / 후 기준으로 수행하는 단위 테스트의 경우 첫 번째는 repository 파트이기 때문에 DB에 데이터를 정확하게 CRUD 할 수 있는가가 초점이었습니다. 
반면 방금 전에 작성한 부분의 경우에는 MockMvc를 이용하여 실제로 postman 같은 서버를 사용하지 않은 상태에서 POST 요청을 "/login"으로 날려보았을 때 결과가 정확하게 나오는지를 확인하는 부분이었습니다. 

근데 여러분이 명심하셨으면 하는 부분에는 저희가 최초 basic auth 형태로 로그인을 시도하려고 할 때도 postman headers 내에 Content-Type을 application/json으로 동일하게 가져갔다는 점입니다.

## Unit Test 관련 예제 문제들
1. Car 정보 삭제 및 확인
CarRepositoryTest에서 CarRepository를 사용하여 특정 자동차 정보를 삭제 한 후 데이터베이스에서 해당 정보가 완전히 삭제되었는지를 검증하는 테스트케이스를 작성하시오.
- 지시 사항
  1. CarRepositoryTest에 새로운 테스트 메서드를 추가
  2. 테스트용 자동차 데이터를 하나 저장합니다.
  3. deleteAll() 혹은 deleteById()을 활용하여 carRepository에 남아있는 데이터가 0인지 확인하여 삭제를 검증.

```java
    @Test
    @DisplayName("차량 삭제 메서드 테스트")
    void deleteCar() {
        // given -> Owner 객체 생성 / 저장 -> Car 객체 생성 / 저장
        Owner owner = new Owner("Gemini", "GPT");
        ownerRepository.save(owner);
        Car car = new Car("Ford", "Mustang", "Red", "ABCDEF", 2021, 567890, owner);
        carRepository.save(car);
        // when -> 삭제
//        carRepository.deleteAll();
        carRepository.deleteById(car.getId());
        // then -> 삭제가 올바로 되었는지 검증하는 assertThat() 구분
//        assertThat(ownerRepository.count()).isEqualTo(0);
        assertThat(ownerRepository.count()).isEqualTo(3);
    }
```

2. 특정 브랜드 자동차 조회
- 문제 : CarRepository에 정의된 메서드들을 참조하여 특정 브랜드의 자동차 조회가 가능한지 검증하시오.
- 지시 사항
  1. CarRepositoryTest에 새로운 테스트 메서드를 추가합니다.
  2. 총 3 개 이상의 자동차 데이터를 미리 저장합니다(각 brand가 두 대까지는 겹칠 수 있게).
  3. findByBrand("Ford")와 같이 특정 브랜드를 조회했을 때 해당 브랜드의 자동차만 반환되는지 assertThat()으로 확인합니다.
  4. return 타입이 list니까 list의 크기와 첫 번째 요소의 브랜드를 검증하시오.
  5. test method명은 findByBrandShouldReturnCar()
```java
    @Test
    @DisplayName("브랜드 검색 메서드 테스트")
    void findByBrandShouldReturnCar() {
        // given - Owner 하나 생성 및 저장 / Car 객체 3 대 생성 및 저장
        Owner owner = new Owner("Gemini", "GPT");
        ownerRepository.save(owner);
        Car car1 = new Car("Ford", "Mustang", "Red", "ABCDEF", 2021, 567890, owner);
        carRepository.save(car1);
        Car car2 = new Car("Ford", "Carnival", "Blue", "BBBDEF", 2024, 599999, owner);
        carRepository.save(car2);
        Car car3 = new Car("Kia", "Lei", "White", "DDCDEF", 2025, 890, owner);
        carRepository.save(car3);
        // when - carRepository.findByBrand("브랜드명") -> 근데 얘 결과 자료형이 뭐였나요.
        //      list라는 것을 확인할 수 있는데,
        List<Car> cars = carRepository.findByBrand("Ford");
        // then에서의 검증은 list 내부의 element의 자료형이 Car 객체일테니까,
        // 그 객체의 getBrand()의 결과값이 우리가 findByBrand()의 argument로 쓴 값과 동일한지를 체크할 수 있겠네요.
        assertThat(cars.get(0).getBrand()).isEqualTo("Ford");
//        assertThat(cars.size()).isEqualTo(2);

    }
```

3. 사용자 이름으로 사용자 조회
- 문제 :  AppUserRepository의 findByUsername 메서드가 정상적으로 사용자를 찾아내는지 테스트하는 케이스를 작성.
- 지시 사항
  1. AppRepositoryTest 생성
  2. AppUserRepository를 주입 받아서 AppUser 데이터를 저장
  3. findByusername("user1")을 호출하고, 결과가 Optional 타입이기 때문에 isPresent()가 true 인지 확인.
  4. 또한 조회된 사용자의 role이 USER인지도 검증하시오.

```java
package com.example.cardatabase;

import com.example.cardatabase.domain.AppUser;
import com.example.cardatabase.domain.AppUserRepository;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;


@DataJpaTest
public class AppRepositoryTest {
    @Autowired
    private AppUserRepository appUserRepository;

    @Test
    @DisplayName("사용자 이름으로 사용자 조회")
    void findByUsernameSouldReturnAppUser() {
        // given - 사용자 데이터 저장
        AppUser user = new AppUser("user1", "user1", "USER");
        appUserRepository.save(user);

        // when - 사용자 이름으로 조회
        Optional<AppUser> foundUser = appUserRepository.findByUsername("user1");

        // then - 결과가 존재하는지, role이 USER인지 검증
        assertThat(foundUser).isPresent();
        assertThat(foundUser.get().getRole()).isEqualTo("USER");
    }
}
```
4. CarController의 GET /cars 엔드포인트의 상태 코드 테스트
- 문제 : CarController의 `/cars` 엔드포인트에 GET 요청을 보냈을 때, HTTP 상태 코드가 200 OK으로 응답하는지 테스트
- 지시사항
  1. CarControllerTest 클래스 생성
  2. `@WebMvcTest(CarConroller.class)` 에너테이션을 사용하여 웹 레이어만 테스트
  3. MockMvc 객체를 `@Autowired`로 주입 받아 fake HTTP 요청을 보내도록 작성
  4. CarRepository는 실제 bean이 아닌 상태에 해당하므로 `@MockBean`을 활용
  5. `mockMvc.perform(get("/cars"))`를 사용하여 요청을 보내고, `andExect(status().isOk())`로 상태 코드를 검증

```java
package com.example.cardatabase;

import com.example.cardatabase.domain.CarRepository;
import com.example.cardatabase.web.CarController;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(CarController.class)
public class CarControllerTest {
    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private CarRepository carRepository;

    @Test
    @DisplayName("GET /cars 요청 테스트 검증")
    void testGetCars() throws Exception {
        this.mockMvc.perform(get("/cars")).andExpect(status().isOk());
    }
}
```