# CORS Filter 추가하기
- CORS(Cross-Origin Resources Sharing) : 클라이언트와 서버가 교차 출처 재요청을 허용할지 거부할지를 결정하게 하는 특정 헤더를 가짐.
- CORS filter는 다른 출처에서 요청을 보내는 프론트엔드와의 통신에서 필요합니다.
- 프론트엔드 상에서 특정 요청이 백엔드로 넘어가게 되는 과정에서 CORS 필터가 요청을 중간에 확인하여, 교차 출처로 식별되면 요청에 적절한 헤더를 추가하여 서로 통신을 주고 받을 수 있도록 허용해줍니다.
- CorsConfigurationSource 인터페이스를 사용합니다.
- 현재까지의 예제에서는 모든 출처의 HTTP 메서드와 헤더를 허용하는 상태입니다.

1. SecurityConfig 클래스를 수정합니다.
수정전
```java
package com.example.cardatabase;

import com.example.cardatabase.service.UserDetailsServiceImpl;
import com.example.cardatabase.AuthenticationFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;
    private final AuthenticationFilter authenticationFilter;
    private final AuthEntryPoint exceptionHandler;

    public SecurityConfig(UserDetailsServiceImpl userDetailsService, AuthenticationFilter authenticationFilter, AuthEntryPoint exceptionHandler) {
        this.userDetailsService = userDetailsService;
        this.authenticationFilter = authenticationFilter;
        this.exceptionHandler = exceptionHandler;
    }

    public void configGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeRequests -> authorizeRequests.requestMatchers(HttpMethod.POST, "/login").permitAll().anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }
}
```

추가 버전
```java
package com.example.cardatabase;

import com.example.cardatabase.service.UserDetailsServiceImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;
    private final AuthenticationFilter authenticationFilter;
    private final AuthEntryPoint exceptionHandler;

    public SecurityConfig(UserDetailsServiceImpl userDetailsService, AuthenticationFilter authenticationFilter, AuthEntryPoint exceptionHandler) {
        this.userDetailsService = userDetailsService;
        this.authenticationFilter = authenticationFilter;
        this.exceptionHandler = exceptionHandler;
    }

    public void configGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeRequests -> authorizeRequests.requestMatchers(HttpMethod.POST, "/login").permitAll().anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(Arrays.asList("*"));
        config.setAllowedMethods(Arrays.asList("*"));
        config.setAllowedHeaders(Arrays.asList("*"));

        config.setAllowCredentials(false);
        config.applyPermitDefaultValues();

        source.registerCorsConfiguration("/**", config);
        return source;
    }
}
```
// 특정 Origin 만을 명시적으로 정의하려면
`config.setAllowOrigins(Arrays.asList("http://localhost:5173", "http://localhost:3000"))`
과 같이 사용할 수 있습니다. 어차피 5173일거니까 ctrl + f로 5173 검색해두세요.
2. SecurityConfig를 수정했으니 filterChain 관련 method도 수정해야합니다.

```java
import static org.springframework.security.config.Customizer.withDefaults;

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.csrf(csrf -> csrf.disable())
            .cors(withDefaults())
            .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authorizeRequests -> authorizeRequests.requestMatchers(HttpMethod.POST, "/login").permitAll().anyRequest().authenticated())
            .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(exceptionHandler));
    return http.build();
}
```

# Role-Based Protection
- Spring Security는 역할을 이용하여 세분화된 역할 기반 보안을 정의할 수 있으며, 사용자는 하나 또는 여러 역할에 할당되어질 수 있다. 역할은 흔히 ADMIN / MANAGER / USER와 같은 계층 구조를 가지게 되는데 USER가 할 수 있는 모든 일은 MANAGER가 다 할 수 있으면서 MANAGER는 USER보다 더 많은 접근 권한을 가지고, ADMIN은 MANAGER가 할 수 있는걸 또 다 할 수 있으면서 지만 할 수 있는 다른 접근 권한을 갖는 등으로 생각하시면 되겠습니다.

SecurityConfig 클래스의 요청 수준에서 역할 기반 접근 제어를 정의할 수 있습니다. 이하의 예제 코드에서는 접근을 위한 특정 역할이 필요한 엔드포인트를 정의할겁니다. `/admin/**` 엔드포인트에 접근하려면 ADMIN 역할이 필요하고, `/user/**` 엔드포인트에 접근하려면 USER 역할이 필요한 등이 되겠습니다. 사용자가 지정된 역할을 가지고 있으면 true를 반환하는 Spring Security hasRole() 메서드를 이용합니다.


Role-Based Protection 적용 filterChain 예시(예제 프로젝트에는 도입하지 않습니다.)
```java
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .cors(withDefaults())
                .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeRequests -> 
                  authorizeHttpRequests.requestMatches("/admin/**").hasRole("ADMIN").requestMatchers("/user/**").hasRole("USER").anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }
```
Spring Security는 Method 수준의 보안을 적용하는 데 이용되는 `@PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter, @Secured` 에너테이션들이 있습니다. 메서드 수준 보안은 default로 spring-boot-starter-security에서 이용하도록 설정되어 있지 않습니다. 스프링 구성 클래스(최상위-저희 기준으로 CarDatabaseApplication)에서 `@EnableMethodSecurity` 에너테이션을 이용하여 활성화해야하는데...
예시로 남겨두지는 않겠습니다.

# BackEnd Tests